STSEG SEGMENT PARA STACK "STACK"
STSEG ENDS

assume CS:CODE, DS:DATA, SS: STSEG
CODE segment
begin:
mov AX, DATA
mov DS, AX
call Welcome  
call User_input				; 
call Message
call Show 					; вывод целого числа с АХ

mov AH, 10h					; ждем нажатия любой клавиши
int 16h
mov AX, 4C00h				; завершение программы
int 21h
;----------------------------------------------------------------------------------------------------------
User_input proc
mov DX, offset Buff_num		; вводим число
mov AH, 10
int 21h

mov SI, offset Buff_num+1	; адрес где лежит кол-во введенных цифр
xor CX, CX 					; обнуление регистра 
mov CL, [SI]				; берем кол-во введенных цифр для цикла
cmp CX, 0					; если ноль - на выход
je exit

mov fl, 0					; по умолчанию сбрасываем флаг негативного числа
inc SI						; берем первый разряд нашего числа
mov AL, [SI]				; пишем его в регстр для обработки
cmp AL,'-'					; если минус - установить флаг
jne positiv			
mov fl, 1					; флаг негативного числа
dec CL						; кло-во цифр стало на 1 меньше
cmp CX, 0					; если кроме минуса там ничего нет - на выход
je exit
inc SI						; следующий разряд нашего числа

positiv:
xor AX, AX
xor DI, DI
mov DI, 10					; 10 - кратность
dec SI						; адрес цифры возвращаем обратно
 
work:
inc SI						; берем следующий разряд нашего числа
xor BX, BX
mov BL, [SI]				; пишем его в регстр для обработки
sub BL, '0'					; обрабатываем его - перобразуем в людской вид, чтоб получить 10-чный вид необходимо отнять код нуля (30h)
cmp BL, 9					; если это не цифра - на выход
ja exit
mul DI						; умножаем его на 10
call Error_Exit_1
add AX, BX					; складываем до с предыдущим
loop work

cmp fl,1					; если у нас отрицательное число
jne no
neg AX						; цепляем ему минус
no:
ret

exit:
call Error_Exit
User_input endp
;----------------------------------------------------------------------------------------------------------
Show proc
mov BX, 10					; основа системы счисления
mov DI, offset Buff_num+6	; счетчик на конец буффера
mov fl, 0					; по умолчанию сбрасываем флаг негативного числа
cmp AX, 0					; наше число отрицаиельное?
jge Pr1
neg AX						; если да, то делаем его положительным
mov fl, 1					; но устанавливаем флаг отриц. числа

Pr1: xor DX, DX				; тут будет остаток
div BX						; делим АХ на 10 - остаток в DX
mov SI, offset Tabl			; адес начала таблицы с символами
add SI, DX					; адрес нужного нам символа
mov DL, [SI]				; загоняем его в память, там где Buff_num
mov [DI], DL
dec DI						; переходим на следующее место

cmp AX, 0					; а не закончилось ли у нас число?
jnz Pr1						; если нет то опять за свое (если не 0)

cmp fl,1					; если у нас отрицательное число
jne show_ok
mov DL, '-'
mov [DI], DL				; цепляем ему минус
dec DI						; переходим на следующее место
show_ok:
mov AH, 9	
inc DI						; если да, то гуляем (выводим число на экран)
mov DX, DI					; это у нас место, где начинается символы числа1			; на самом деле чуть правее
int 21h
ret
Show endp
;----------------------------------------------------------------------------------------------------------
Message proc				; сообщаем, что все хорошо
push AX
mov DX, offset text1
mov AH, 9
int 21h
pop AX
ret
Message endp
;----------------------------------------------------------------------------------------------------------
Welcome proc					; сообщаем, что все хорошо
push AX
mov DX, offset text_welcome
mov AH, 9
int 21h
pop AX
ret
Welcome endp
;----------------------------------------------------------------------------------------------------------
Error_Exit proc					; сообщаем, что все пропало и выходим
mov DX, offset text2
mov AH, 9
int 21h
; ждем нажатия любой клавиши
mov AH, 10h
int 16h
mov AX, 4C00h 					; завершение программы
int 21h
ret
Error_Exit endp

;----------------------------------------------------------------------------------------------------------
Error_Exit_1 proc					; сообщаем, что все пропало и выходим
xor AX, AX

push AX
mov DX, offset text3
mov AH, 9
int 21h
pop AX

mov AH, 10h
int 16h
mov AX, 4C00h 					; завершение программы
int 21h
ret
Error_Exit_1 endp
;----------------------------------------------------------------------------------------------------------
CODE ends

DATA segment 					; сегмент данных 
Buff_num db 6, 7 dup(0), '$'  	;создаем буффер для записи числа, для вывода помещаем в конец символ '$'
fl db 0
Tabl db '0123456789' 			;для выведения символов цифр
text_welcome db 13, 10, 'Please, enter some random number:', 13, 10, '$' ; сообжение с новой строки
text3 db 13, 10, 'OVERFLOW!', 13, 10, '$' ; сообжение с новой строки
text1 db 13, 10, 'Number is correct!', 13, 10, '$' ; сообжение с новой строки
text2 db 13, 10, 'Error! Exit!', 13, 10, '$' ; -//-
end

end begin
